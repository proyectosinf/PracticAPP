# PracticApp

PracticApp is an iOS application that helps you find nearby gas stations and compare fuel prices in real-time. Find the best deals and save on every refill.

## Table of Contents

- [Requirements](#requirements)
- [Project Structure](#project-structure)
  - [Modules](#modules)
- [Architecture](#architecture)
  - [Generated Files](#generated-files)
- [Navigation](#navigation)
- [Naming Conventions for Models](#naming-conventions-for-models)
  - [Protocols (Interfaces)](#protocols-interfaces)
  - [Data Layer](#data-layer)
  - [Domain Layer](#domain-layer)
  - [UI Layer](#ui-layer)
- [Dependency Injection](#dependency-injection)
- [Development Environment Setup](#development-environment-setup)
  - [Homebrew Dependencies (`Brewfile`)](#homebrew-dependencies-brewfile)
  - [Ruby Dependencies (`Gemfile`)](#ruby-dependencies-gemfile)
- [Development Tasks (`Rakefile`)](#development-tasks-rakefile)
  - [Code Formatting & Linting](#code-formatting--linting)
  - [Localization](#localization)
  - [Mocks](#mocks)
  - [Xcode Templates](#xcode-templates)

## Requirements

- The required Xcode version is specified in [.xcode-version](.xcode-version).
- Swift 6.0
- Minimum iOS SDK: 17.0
- Target device: iPhone
- UI Framework: SwiftUI

## Project Structure

The project follows a modular architecture using a Swift Package located at `Modules/Package.swift`. This package is added as a dependency in the main application workspace: `PracticApp.xcworkspace`.

```text
.
├── App/                      # Main application target
│   ├── Assets.xcassets/      # Asset catalog
│   ├── Firebase/             # Firebase configuration files
│   ├── Preview Content/      # SwiftUI Preview assets
│   ├── SupportingFiles/      # Info.plist, Entitlements, etc.
│   ├── AppDelegate.swift     # Application Delegate
│   └── PracticApp.swift       # Main application entry point (SwiftUI App life cycle)
├── Modules/                  # Swift Package containing all modules
│   ├── Sources/              # Module sources
│   │   ├── AppCommon/        # Common application code (Design System, Localizations, DI, Coordinators, etc.)
│   │   ├── AppNavigation/    # Initial navigation logic
│   │   ├── Data/             # Data layer (Repositories Impl, API/DB/Local Models)
│   │   ├── Domain/           # Domain layer (Use Cases, Repository Protocols, Domain Models)
│   │   ├── FeatureXXX/       # Feature modules (e.g., FeatureEnergyStations, FeatureProfile)
│   │   ├── FoundationUtils/  # Foundation extensions and helpers
│   │   ├── Logger/           # Logging utility
│   │   └── TestsUtils/       # Utilities for testing
│   ├── Tests/                # Module unit tests
│   │   ├── AppCommonTests/
│   │   ├── DataTests/
│   │   ├── DomainTests/
│   │   ├── FeatureXXXTests/  # Feature module tests
│   │   └── FoundationUtilsTests/
│   └── Package.swift         # Swift Package manifest
├── PracticApp.xcworkspace/       # Xcode Workspace
├── ConfigFiles/              # Configuration files (e.g., for different environments)
├── fastlane/                 # Fastlane setup for automation
├── scripts/                  # Utility scripts
├── .swiftlint.yml            # SwiftLint configuration
├── .swiftformat              # SwiftFormat configuration
├── .sourcery.yml             # Sourcery configuration
├── Brewfile                  # Homebrew dependencies
├── Gemfile                   # Ruby Gem dependencies (Bundler)
├── Rakefile                  # Rake tasks for automation (templates, localize, format, mocks)
├── README.md                 # This file
└── ...                       # Other configuration files (.gitignore, .xcode-version, etc.)
```

### Modules

| Module              | Description |
|---------------------|-------------|
| **AppCommon**       | Contains common code for the application layer (Design system, localizations, coordinators, DI registrations, etc.). |
| **AppNavigation**   | Entry point of the app, handling initial navigation (e.g., Splash -> MainView). |
| **Domain**          | Contains application use cases and business logic. |
| **Data**            | Manages data access logic, models, and repositories for API and local storage. |
| **FeatureXXX**      | Each feature has its own module. Modules do not reference each other to prevent cyclic dependencies. |
| **FoundationUtils** | Provides extensions and helpers for Foundation and other non-UI frameworks. |
| **Logger**          | Handles application logging. |
| **Mocks**           | Contains mock implementations generated by Sourcery for unit tests. |
| **TestsUtils**      | Utilities and helpers used across different test targets. |

## Architecture

The UI layer follows the **MVVM** pattern. To facilitate this structure, an **Xcode template** is available for generating views and their corresponding view models (see [Xcode Templates](#xcode-templates) section for installation).

### Generated Files

| File                        | Description |
|-----------------------------|-------------|
| **XXXScreen**               | Represents different states of its associated view model and handles user interactions. |
| **XXXScreen+ViewModel**     | Updates the view state based on user interactions and business logic. |

For data access in view models, repositories are defined within the **Domain** module (e.g., `UserRepository`, `DioceseRepository`) and implemented in the **Data** module. If business logic is complex or shared across multiple features, it is encapsulated in the **Domain** layer's use cases.

## Navigation

Application navigation is managed using the **Coordinator pattern**. This pattern isolates navigation logic from SwiftUI views, improving modularity and testability.

- **Entry Point**: The initial navigation flow (e.g., handling splash screen, onboarding, or main interface presentation) is managed by the `AppNavigation` module.
- **Flow Coordinators**: Each major feature or section of the app typically has its own `Coordinator` (e.g., `EnergyStationsCoordinator`, `ProfileCoordinator`). These coordinators are responsible for managing the sequence of screens within a specific flow, often associated with a `NavigationView`.
- **Coordinator Responsibilities**:
    - Creating and configuring view models and views from various feature modules.
    - Presenting views (pushing onto a navigation stack, presenting modally).
    - Handling navigation between screens within its flow.
    - Starting other coordinators (for sub-flows or modal presentations like sheets or fullscreen covers).
- **Location**: To prevent cyclic dependencies between feature modules (`FeatureXXX`), **all coordinators are located within the `AppCommon` module**. This allows a single coordinator to manage navigation flows that may involve screens from multiple different feature modules without coupling those modules directly.
- **Data Passing**: Data required by a flow or screen is typically passed down through the coordinator during initialization or via specific methods.

This approach keeps view models and views focused on presentation logic and state management, while coordinators handle the "where to go next" logic.

## Naming Conventions for Models

To maintain consistency across the codebase, we follow these naming conventions for data models and protocols across different architectural layers:

### Protocols (Interfaces)

Used to define contracts, primarily for data access and business logic.

*   **Protocol Definitions**:
    *   **Purpose**: Define the interface (contract).
    *   **Suffix**: `Repository`
    *   **Example**: `UserRepository`, `EnergyStationsRepository`

*   **Implementations**: Concrete classes that implement the defined protocols.
    *   **Purpose**: Provide the concrete implementation of the contract.
    *   **Suffix**: `RepositoryImpl`
    *   **Example**: `UserRepositoryImpl`, `EnergyStationsRepositoryImpl`

### Data Layer

Models representing the structure of data as it is received or stored.

*   **API Models**: Represent the structure of data received from external APIs.
    *   **Suffix**: `Data`
    *   **Example**: `UserData`, `EnergyStationData`

*   **Database Models**: Represent entities stored in the local database (e.g., SwiftData).
    *   **Suffix**: `DB`
    *   **Example**: `UserDB`, `EnergyStationDB`

*   **Local Models**: Represent data stored locally (e.g., UserDefaults, Keychain).
    *   **Suffix**: `Local`
    *   **Example**: `SettingsLocal`, `AuthTokenLocal`

### Domain Layer

Models representing the core business objects and concepts of the application.

*   **Domain Models**:
    *   **Suffix**: None (use the direct conceptual name).
    *   **Example**: `User`, `EnergyStation`, `FuelType`

### UI Layer

Models specific to the presentation and state of the user interface.

*   **View State Models**: Define the structure of the state that the `ViewModel` exposes to the `View`.
    *   **Suffix**: `UIState`
    *   **Example**: `UserProfileUIState`, `EnergyStationsMapUIState`

## Dependency Injection

This project uses [Factory](https://github.com/hmlongco/Factory) for dependency injection.

- Internal dependencies are declared within their respective modules inside the `DI/` directory (e.g., `DI/Dependencies.swift`).
- **Repositories** and **Use Cases** are registered in `AppCommon` under:
  - `DI/RepositoryFactory.swift` (for repositories)
  - `DI/UseCaseFactory.swift` (for use cases)

## Development Environment Setup

To ensure a consistent development environment and manage project dependencies, follow these steps:

### Homebrew Dependencies (`Brewfile`)

This project depends on several tools installed via [Homebrew](https://brew.sh/). The dependencies are listed in the `Brewfile`. To install or update them, run:

```sh
$ brew bundle install
```
This command will install all tools listed in the `Brewfile`, such as `swiftlint`, `swiftformat`, `sourcery`, etc.

### Ruby Dependencies (`Gemfile`)

Some development tasks rely on Ruby Gems (libraries). These are managed using [Bundler](https://bundler.io/), which ensures that all developers use the exact same versions of these gems, specified in the `Gemfile`.

To install the required Ruby gems:

```sh
$ bundle install
```
After installing, always prefix commands that use these gems with `bundle exec` (e.g., `bundle exec rake`, `bundle exec fastlane`). This ensures the correct versions specified in `Gemfile.lock` are used.

## Development Tasks (`Rakefile`)

Common development tasks are automated using [Rake](https://ruby.github.io/rake/), a Ruby-based build tool similar to Make. Tasks are defined in the `Rakefile`. Always run Rake tasks using Bundler:

```sh
$ bundle exec rake <task_name>
```

Here are some of the available tasks:

### Code Formatting & Linting

Code style is enforced using [SwiftLint](https://github.com/realm/SwiftLint) (rules in `.swiftlint.yml`) and automatic formatting is done with [SwiftFormat](https://github.com/nicklockwood/SwiftFormat) (configuration in `.swiftformat`).

To apply formatting and fix lint issues automatically, run:

```sh
$ bundle exec rake format

# Alternatively, run each tool separately (ensure they are installed via Brewfile):
$ swiftformat .
$ swiftlint --fix --format
```

### Localization

Localized texts and translations are stored in the **AppCommon** module. They are generated from a Google Sheet using the [Localio](https://bitbucket.org/mobivery-public/localio) Ruby gem.

To generate or update localization files from the spreadsheet, run:

```sh
$ bundle exec rake localize
```

### Mocks

Mock implementations for protocols (used in unit tests) are automatically generated using [Sourcery](https://github.com/krzysztofzablocki/Sourcery) (configuration in `.sourcery.yml`).

To generate mocks, first annotate the protocols you want to mock:

```swift
// sourcery: AutoMockable
public protocol MyServiceProtocol {
    // ... methods ...
}
```

Then, run the generation task:

```sh
$ bundle exec rake mocks

# This task typically runs Sourcery, SwiftFormat, and SwiftLint subsequently.
# Alternatively, run Sourcery manually (ensure it's installed via Brewfile):
# $ sourcery --config .sourcery.yml
```
Generated mocks will be placed in the `Mocks` module source directory.

### Xcode Templates

Several Xcode templates are provided to speed up development and maintain consistency when creating common architectural components.

To install the templates for Xcode, run:

```sh
$ bundle exec rake templates
```
After running this command, the following templates will be available when adding new files to the project in Xcode:

| Template Name             | Description |
|---------------------------|-------------|
| **MVVM Screen**    | Generates a SwiftUI `View` and its associated `ViewModel`, following the MVVM pattern. Includes boilerplate for state management and dependency injection. |
| **Navigation**     | Generates a SwiftUI `View` to host a navigation flow using `NavigationStack` and its corresponding `Coordinator` class responsible for managing that flow's navigation path. |
| **Use Case**       | Generates a `UseCase` class within the Domain layer to encapsulate specific business logic. |
| **Repository**     | Generates a `Repository` protocol in the Domain layer and its corresponding `RepositoryImpl` implementation in the Data layer. |
| **Data Source**    | Generates a `DataSource` protocol and implementation class within the Data layer, typically used for interacting with a specific data source like an API endpoint or local database. |
| **Model**          | Generates data model files. It prompts for the model type (e.g., API Data, Domain, UI State) and automatically applies the correct suffix (`Data`, none, `UIState`) according to the [Naming Conventions](#naming-conventions-for-models). |

Using these templates helps ensure that new components adhere to the established project architecture and naming conventions.

